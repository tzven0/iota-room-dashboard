!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@iota/crypto.js"),require("big-integer"),require("@iota/util.js")):"function"==typeof define&&define.amd?define(["exports","@iota/crypto.js","big-integer","@iota/util.js"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Iota={},e.IotaCrypto,e.bigInt,e.IotaUtil)}(this,(function(e,t,n,s){"use strict";function i(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var r=i(n);class o{constructor(e){this._publicKey=e}toAddress(){return t.Blake2b.sum256(this._publicKey)}verify(e){return t.ArrayHelper.equal(this.toAddress(),e)}}o.ADDRESS_LENGTH=t.Blake2b.SIZE_256;const a=t.Blake2b.SIZE_256,d=t.Blake2b.SIZE_256,l=t.Blake2b.SIZE_256,u=1+o.ADDRESS_LENGTH;function c(e){if(!e.hasRemaining(1))throw new Error(`Address data is ${e.length()} in length which is less than the minimimum size required of 1`);const t=e.readByte("address.type",!1);let n;if(0!==t)throw new Error(`Unrecognized address type ${t}`);return n=h(e),n}function p(e,t){if(0!==t.type)throw new Error(`Unrecognized address type ${t.type}`);y(e,t)}function h(e){if(!e.hasRemaining(u))throw new Error(`Ed25519 address data is ${e.length()} in length which is less than the minimimum size required of ${u}`);const t=e.readByte("ed25519Address.type");if(0!==t)throw new Error(`Type mismatch in ed25519Address ${t}`);return{type:0,address:e.readFixedHex("ed25519Address.address",o.ADDRESS_LENGTH)}}function y(e,t){e.writeByte("ed25519Address.type",t.type),e.writeFixedHex("ed25519Address.address",o.ADDRESS_LENGTH,t.address)}const f=49+u+8;function g(e){const t=e.readUInt16("funds.numFunds"),n=[];for(let s=0;s<t;s++)n.push(w(e));return n}function m(e,t){if(t.length>127)throw new Error(`The maximum number of funds is 127, you have provided ${t.length}`);e.writeUInt16("funds.numFunds",t.length);for(let n=0;n<t.length;n++)I(e,t[n])}function w(e){if(!e.hasRemaining(f))throw new Error(`Migrated funds data is ${e.length()} in length which is less than the minimimum size required of ${f}`);const t=e.readFixedHex("migratedFunds.tailTransactionHash",49),n=c(e),s=e.readUInt64("migratedFunds.deposit");return{tailTransactionHash:t,address:n,deposit:Number(s)}}function I(e,t){e.writeFixedHex("migratedFunds.tailTransactionHash",49,t.tailTransactionHash),p(e,t.address),e.writeUInt64("migratedFunds.deposit",r.default(t.deposit))}const T=1+d+2,E=1+d;function _(e){const t=e.readUInt16("inputs.numInputs"),n=[];for(let s=0;s<t;s++)n.push(U(e));return n}function x(e,t){if(t.length<1)throw new Error(`The minimum number of inputs is 1, you have provided ${t.length}`);if(t.length>127)throw new Error(`The maximum number of inputs is 127, you have provided ${t.length}`);e.writeUInt16("inputs.numInputs",t.length);for(let n=0;n<t.length;n++)S(e,t[n])}function U(e){if(!e.hasRemaining(1))throw new Error(`Input data is ${e.length()} in length which is less than the minimimum size required of 1`);const t=e.readByte("input.type",!1);let n;if(0===t)n=$(e);else{if(1!==t)throw new Error(`Unrecognized input type ${t}`);n=P(e)}return n}function S(e,t){if(0===t.type)M(e,t);else{if(1!==t.type)throw new Error(`Unrecognized input type ${t.type}`);A(e,t)}}function $(e){if(!e.hasRemaining(T))throw new Error(`UTXO Input data is ${e.length()} in length which is less than the minimimum size required of ${T}`);const t=e.readByte("utxoInput.type");if(0!==t)throw new Error(`Type mismatch in utxoInput ${t}`);return{type:0,transactionId:e.readFixedHex("utxoInput.transactionId",d),transactionOutputIndex:e.readUInt16("utxoInput.transactionOutputIndex")}}function M(e,t){e.writeByte("utxoInput.type",t.type),e.writeFixedHex("utxoInput.transactionId",d,t.transactionId),e.writeUInt16("utxoInput.transactionOutputIndex",t.transactionOutputIndex)}function P(e){if(!e.hasRemaining(E))throw new Error(`Treasury Input data is ${e.length()} in length which is less than the minimimum size required of ${E}`);const t=e.readByte("treasuryInput.type");if(1!==t)throw new Error(`Type mismatch in treasuryInput ${t}`);return{type:1,milestoneId:e.readFixedHex("treasuryInput.milestoneId",d)}}function A(e,t){e.writeByte("treasuryInput.type",t.type),e.writeFixedHex("treasuryInput.milestoneId",d,t.milestoneId)}const N=2+u,v=2+u;function R(e){const t=e.readUInt16("outputs.numOutputs"),n=[];for(let s=0;s<t;s++)n.push(k(e));return n}function B(e,t){if(t.length<1)throw new Error(`The minimum number of outputs is 1, you have provided ${t.length}`);if(t.length>127)throw new Error(`The maximum number of outputs is 127, you have provided ${t.length}`);e.writeUInt16("outputs.numOutputs",t.length);for(let n=0;n<t.length;n++)O(e,t[n])}function k(e){if(!e.hasRemaining(1))throw new Error(`Output data is ${e.length()} in length which is less than the minimimum size required of 1`);const t=e.readByte("output.type",!1);let n;if(0===t)n=H(e);else if(1===t)n=b(e);else{if(2!==t)throw new Error(`Unrecognized output type ${t}`);n=C(e)}return n}function O(e,t){if(0===t.type)L(e,t);else if(1===t.type)z(e,t);else{if(2!==t.type)throw new Error(`Unrecognized output type ${t.type}`);G(e,t)}}function H(e){if(!e.hasRemaining(N))throw new Error(`Signature Locked Single Output data is ${e.length()} in length which is less than the minimimum size required of ${N}`);const t=e.readByte("sigLockedSingleOutput.type");if(0!==t)throw new Error(`Type mismatch in sigLockedSingleOutput ${t}`);const n=c(e),s=e.readUInt64("sigLockedSingleOutput.amount");return{type:0,address:n,amount:Number(s)}}function L(e,t){e.writeByte("sigLockedSingleOutput.type",t.type),p(e,t.address),e.writeUInt64("sigLockedSingleOutput.amount",r.default(t.amount))}function b(e){if(!e.hasRemaining(v))throw new Error(`Signature Locked Dust Allowance Output data is ${e.length()} in length which is less than the minimimum size required of ${v}`);const t=e.readByte("sigLockedDustAllowanceOutput.type");if(1!==t)throw new Error(`Type mismatch in sigLockedDustAllowanceOutput ${t}`);const n=c(e),s=e.readUInt64("sigLockedDustAllowanceOutput.amount");return{type:1,address:n,amount:Number(s)}}function z(e,t){e.writeByte("sigLockedDustAllowanceOutput.type",t.type),p(e,t.address),e.writeUInt64("sigLockedDustAllowanceOutput.amount",r.default(t.amount))}function C(e){if(!e.hasRemaining(9))throw new Error(`Treasury Output data is ${e.length()} in length which is less than the minimimum size required of 9`);const t=e.readByte("treasuryOutput.type");if(2!==t)throw new Error(`Type mismatch in treasuryOutput ${t}`);const n=e.readUInt64("treasuryOutput.amount");return{type:2,amount:Number(n)}}function G(e,t){e.writeByte("treasuryOutput.type",t.type),e.writeUInt64("treasuryOutput.amount",r.default(t.amount))}function D(e){if(!e.hasRemaining(9))throw new Error(`Transaction essence data is ${e.length()} in length which is less than the minimimum size required of 9`);const t=e.readByte("transactionEssence.type");if(0!==t)throw new Error(`Type mismatch in transactionEssence ${t}`);const n=_(e),s=R(e),i=ae(e);if(i&&2!==i.type)throw new Error("Transaction essence can only contain embedded Indexation Payload");for(const e of n)if(0!==e.type)throw new Error("Transaction essence can only contain UTXO Inputs");for(const e of s)if(0!==e.type&&1!==e.type)throw new Error("Transaction essence can only contain sig locked single input or sig locked dust allowance outputs");return{type:0,inputs:n,outputs:s,payload:i}}function F(e,t){e.writeByte("transactionEssence.type",t.type);for(const e of t.inputs)if(0!==e.type)throw new Error("Transaction essence can only contain UTXO Inputs");x(e,t.inputs);for(const e of t.outputs)if(0!==e.type&&1!==e.type)throw new Error("Transaction essence can only contain sig locked single input or sig locked dust allowance outputs");B(e,t.outputs),de(e,t.payload)}const K=1+t.Ed25519.SIGNATURE_SIZE+t.Ed25519.PUBLIC_KEY_SIZE;function Y(e){if(!e.hasRemaining(1))throw new Error(`Signature data is ${e.length()} in length which is less than the minimimum size required of 1`);const t=e.readByte("signature.type",!1);let n;if(0!==t)throw new Error(`Unrecognized signature type ${t}`);return n=q(e),n}function W(e,t){if(0!==t.type)throw new Error(`Unrecognized signature type ${t.type}`);X(e,t)}function q(e){if(!e.hasRemaining(K))throw new Error(`Ed25519 signature data is ${e.length()} in length which is less than the minimimum size required of ${K}`);const n=e.readByte("ed25519Signature.type");if(0!==n)throw new Error(`Type mismatch in ed25519Signature ${n}`);return{type:0,publicKey:e.readFixedHex("ed25519Signature.publicKey",t.Ed25519.PUBLIC_KEY_SIZE),signature:e.readFixedHex("ed25519Signature.signature",t.Ed25519.SIGNATURE_SIZE)}}function X(e,n){e.writeByte("ed25519Signature.type",n.type),e.writeFixedHex("ed25519Signature.publicKey",t.Ed25519.PUBLIC_KEY_SIZE,n.publicKey),e.writeFixedHex("ed25519Signature.signature",t.Ed25519.SIGNATURE_SIZE,n.signature)}function Z(e){const t=e.readUInt16("transactionEssence.numUnlockBlocks"),n=[];for(let s=0;s<t;s++)n.push(j(e));return n}function J(e,t){e.writeUInt16("transactionEssence.numUnlockBlocks",t.length);for(let n=0;n<t.length;n++)V(e,t[n])}function j(e){if(!e.hasRemaining(1))throw new Error(`Unlock Block data is ${e.length()} in length which is less than the minimimum size required of 1`);const t=e.readByte("unlockBlock.type",!1);let n;if(0===t)n=Q(e);else{if(1!==t)throw new Error(`Unrecognized unlock block type ${t}`);n=te(e)}return n}function V(e,t){if(0===t.type)ee(e,t);else{if(1!==t.type)throw new Error(`Unrecognized unlock block type ${t.type}`);ne(e,t)}}function Q(e){if(!e.hasRemaining(2))throw new Error(`Signature Unlock Block data is ${e.length()} in length which is less than the minimimum size required of 2`);const t=e.readByte("signatureUnlockBlock.type");if(0!==t)throw new Error(`Type mismatch in signatureUnlockBlock ${t}`);return{type:0,signature:Y(e)}}function ee(e,t){e.writeByte("signatureUnlockBlock.type",t.type),W(e,t.signature)}function te(e){if(!e.hasRemaining(3))throw new Error(`Reference Unlock Block data is ${e.length()} in length which is less than the minimimum size required of 3`);const t=e.readByte("referenceUnlockBlock.type");if(1!==t)throw new Error(`Type mismatch in referenceUnlockBlock ${t}`);return{type:1,reference:e.readUInt16("referenceUnlockBlock.reference")}}function ne(e,t){e.writeByte("referenceUnlockBlock.type",t.type),e.writeUInt16("referenceUnlockBlock.reference",t.reference)}const se=16+a+a+l+8+1+t.Ed25519.PUBLIC_KEY_SIZE+1+t.Ed25519.SIGNATURE_SIZE,ie=10+f,re=4+E+9,oe=64;function ae(e){const t=e.readUInt32("payload.length");if(!e.hasRemaining(t))throw new Error(`Payload length ${t} exceeds the remaining data ${e.unused()}`);let n;if(t>0){const t=e.readUInt32("payload.type",!1);if(0===t)n=le(e);else if(1===t)n=ce(e);else if(2===t)n=he(e);else if(3===t)n=fe(e);else{if(4!==t)throw new Error(`Unrecognized payload type ${t}`);n=me(e)}}return n}function de(e,t){const n=e.getWriteIndex();if(e.writeUInt32("payload.length",0),t)if(0===t.type)ue(e,t);else if(1===t.type)pe(e,t);else if(2===t.type)ye(e,t);else if(3===t.type)ge(e,t);else{if(4!==t.type)throw new Error(`Unrecognized transaction type ${t.type}`);we(e,t)}else;const s=e.getWriteIndex();e.setWriteIndex(n),e.writeUInt32("payload.length",s-n-4),e.setWriteIndex(s)}function le(e){if(!e.hasRemaining(8))throw new Error(`Transaction Payload data is ${e.length()} in length which is less than the minimimum size required of 8`);const t=e.readUInt32("payloadTransaction.type");if(0!==t)throw new Error(`Type mismatch in payloadTransaction ${t}`);let n,s;if(0!==e.readByte("payloadTransaction.essenceType",!1))throw new Error(`Unrecognized transaction essence type ${t}`);return n=D(e),s=Z(e),{type:0,essence:n,unlockBlocks:s}}function ue(e,t){if(e.writeUInt32("payloadMilestone.type",t.type),0!==t.type)throw new Error(`Unrecognized transaction type ${t.type}`);F(e,t.essence),J(e,t.unlockBlocks)}function ce(e){if(!e.hasRemaining(se))throw new Error(`Milestone Payload data is ${e.length()} in length which is less than the minimimum size required of ${se}`);const n=e.readUInt32("payloadMilestone.type");if(1!==n)throw new Error(`Type mismatch in payloadMilestone ${n}`);const s=e.readUInt32("payloadMilestone.index"),i=e.readUInt64("payloadMilestone.timestamp"),r=e.readByte("payloadMilestone.numParents"),o=[];for(let t=0;t<r;t++){const n=e.readFixedHex(`payloadMilestone.parentMessageId${t+1}`,a);o.push(n)}const d=e.readFixedHex("payloadMilestone.inclusionMerkleProof",l),u=e.readUInt32("payloadMilestone.nextPoWScore"),c=e.readUInt32("payloadMilestone.nextPoWScoreMilestoneIndex"),p=e.readByte("payloadMilestone.publicKeysCount"),h=[];for(let n=0;n<p;n++)h.push(e.readFixedHex("payloadMilestone.publicKey",t.Ed25519.PUBLIC_KEY_SIZE));const y=ae(e);if(y&&3!==y.type)throw new Error("Milestones only support embedded receipt payload type");const f=e.readByte("payloadMilestone.signaturesCount"),g=[];for(let n=0;n<f;n++)g.push(e.readFixedHex("payloadMilestone.signature",t.Ed25519.SIGNATURE_SIZE));return{type:1,index:s,timestamp:Number(i),parentMessageIds:o,inclusionMerkleProof:d,nextPoWScore:u,nextPoWScoreMilestoneIndex:c,publicKeys:h,receipt:y,signatures:g}}function pe(e,n){if(e.writeUInt32("payloadMilestone.type",n.type),e.writeUInt32("payloadMilestone.index",n.index),e.writeUInt64("payloadMilestone.timestamp",r.default(n.timestamp)),n.parentMessageIds.length<_e)throw new Error(`A minimum of ${_e} parents is allowed, you provided ${n.parentMessageIds.length}`);if(n.parentMessageIds.length>Ee)throw new Error(`A maximum of ${Ee} parents is allowed, you provided ${n.parentMessageIds.length}`);if(new Set(n.parentMessageIds).size!==n.parentMessageIds.length)throw new Error("The milestone parents must be unique");const s=n.parentMessageIds.slice().sort();e.writeByte("payloadMilestone.numParents",n.parentMessageIds.length);for(let t=0;t<n.parentMessageIds.length;t++){if(s[t]!==n.parentMessageIds[t])throw new Error("The milestone parents must be lexographically sorted");e.writeFixedHex(`payloadMilestone.parentMessageId${t+1}`,a,n.parentMessageIds[t])}e.writeFixedHex("payloadMilestone.inclusionMerkleProof",l,n.inclusionMerkleProof),e.writeUInt32("payloadMilestone.nextPoWScore",n.nextPoWScore),e.writeUInt32("payloadMilestone.nextPoWScoreMilestoneIndex",n.nextPoWScoreMilestoneIndex),e.writeByte("payloadMilestone.publicKeysCount",n.publicKeys.length);for(let s=0;s<n.publicKeys.length;s++)e.writeFixedHex("payloadMilestone.publicKey",t.Ed25519.PUBLIC_KEY_SIZE,n.publicKeys[s]);de(e,n.receipt),e.writeByte("payloadMilestone.signaturesCount",n.signatures.length);for(let s=0;s<n.signatures.length;s++)e.writeFixedHex("payloadMilestone.signature",t.Ed25519.SIGNATURE_SIZE,n.signatures[s])}function he(e){if(!e.hasRemaining(9))throw new Error(`Indexation Payload data is ${e.length()} in length which is less than the minimimum size required of 9`);const t=e.readUInt32("payloadIndexation.type");if(2!==t)throw new Error(`Type mismatch in payloadIndexation ${t}`);const n=e.readUInt16("payloadIndexation.indexLength"),s=e.readFixedHex("payloadIndexation.index",n),i=e.readUInt32("payloadIndexation.dataLength");return{type:2,index:s,data:e.readFixedHex("payloadIndexation.data",i)}}function ye(e,t){if(t.index.length<1)throw new Error(`The indexation key length is ${t.index.length}, which is below the minimum size of 1`);if(t.index.length/2>oe)throw new Error(`The indexation key length is ${t.index.length/2}, which exceeds the maximum size of 64`);e.writeUInt32("payloadIndexation.type",t.type),e.writeUInt16("payloadIndexation.indexLength",t.index.length/2),e.writeFixedHex("payloadIndexation.index",t.index.length/2,t.index),t.data?(e.writeUInt32("payloadIndexation.dataLength",t.data.length/2),e.writeFixedHex("payloadIndexation.data",t.data.length/2,t.data)):e.writeUInt32("payloadIndexation.dataLength",0)}function fe(e){if(!e.hasRemaining(ie))throw new Error(`Receipt Payload data is ${e.length()} in length which is less than the minimimum size required of ${ie}`);const t=e.readUInt32("payloadReceipt.type");if(3!==t)throw new Error(`Type mismatch in payloadReceipt ${t}`);const n=e.readUInt32("payloadReceipt.migratedAt"),s=e.readBoolean("payloadReceipt.final"),i=g(e),r=ae(e);if(!r||4!==r.type)throw new Error(`payloadReceipts can only contain treasury payloads ${t}`);return{type:3,migratedAt:n,final:s,funds:i,transaction:r}}function ge(e,t){e.writeUInt32("payloadReceipt.type",t.type),e.writeUInt32("payloadReceipt.migratedAt",t.migratedAt),e.writeBoolean("payloadReceipt.final",t.final),m(e,t.funds),de(e,t.transaction)}function me(e){if(!e.hasRemaining(re))throw new Error(`Treasure Transaction Payload data is ${e.length()} in length which is less than the minimimum size required of ${re}`);const t=e.readUInt32("payloadTreasuryTransaction.type");if(4!==t)throw new Error(`Type mismatch in payloadTreasuryTransaction ${t}`);return{type:4,input:P(e),output:C(e)}}function we(e,t){e.writeUInt32("payloadTreasuryTransaction.type",t.type),A(e,t.input),G(e,t.output)}const Ie=9+a+4+8,Te=32768,Ee=8,_e=1;function xe(e,t){var n,s,i,o;e.writeUInt64("message.networkId",r.default(null!==(n=t.networkId)&&void 0!==n?n:"0"));const d=null!==(i=null===(s=t.parentMessageIds)||void 0===s?void 0:s.length)&&void 0!==i?i:0;if(e.writeByte("message.numParents",d),t.parentMessageIds){if(d>Ee)throw new Error(`A maximum of ${Ee} parents is allowed, you provided ${d}`);if(new Set(t.parentMessageIds).size!==d)throw new Error("The message parents must be unique");const n=t.parentMessageIds.slice().sort();for(let s=0;s<d;s++){if(n[s]!==t.parentMessageIds[s])throw new Error("The message parents must be lexographically sorted");e.writeFixedHex(`message.parentMessageId${s+1}`,a,t.parentMessageIds[s])}}if(t.payload&&0!==t.payload.type&&2!==t.payload.type&&1!==t.payload.type)throw new Error("Messages can only contain transaction, indexation or milestone payloads");de(e,t.payload),e.writeUInt64("message.nonce",r.default(null!==(o=t.nonce)&&void 0!==o?o:"0"))}class Ue extends Error{constructor(e,t,n,s){super(e),this.route=t,this.httpStatus=n,this.code=s}}class Se{constructor(e,t){var n,s,i;if(!e)throw new Error("The endpoint can not be empty");if(this._endpoint=e.replace(/\/+$/,""),this._basePath=null!==(n=null==t?void 0:t.basePath)&&void 0!==n?n:"/api/v1/",this._powProvider=null==t?void 0:t.powProvider,this._timeout=null==t?void 0:t.timeout,this._userName=null==t?void 0:t.userName,this._password=null==t?void 0:t.password,this._headers=null==t?void 0:t.headers,this._userName&&this._password&&!this._endpoint.startsWith("https"))throw new Error("Basic authentication requires the endpoint to be https");if(this._userName&&this._password&&((null===(s=this._headers)||void 0===s?void 0:s.authorization)||(null===(i=this._headers)||void 0===i?void 0:i.Authorization)))throw new Error("You can not supply both user/pass and authorization header")}async health(){const e=await this.fetchStatus("/health");if(200===e)return!0;if(503===e)return!1;throw new Ue("Unexpected response code","/health",e)}async info(){return this.fetchJson("get","info")}async tips(){return this.fetchJson("get","tips")}async message(e){return this.fetchJson("get",`messages/${e}`)}async messageMetadata(e){return this.fetchJson("get",`messages/${e}/metadata`)}async messageRaw(e){return this.fetchBinary("get",`messages/${e}/raw`)}async messageSubmit(e){let t=0;if(this._powProvider){const n=await this.getPoWInfo();if(t=n.minPoWScore,!e.parentMessageIds||0===e.parentMessageIds.length){const t=await this.tips();e.parentMessageIds=t.tipMessageIds}e.networkId&&0!==e.networkId.length||(e.networkId=n.networkId.toString())}const n=new s.WriteStream;xe(n,e);const i=n.finalBytes();if(i.length>Te)throw new Error(`The message length is ${i.length}, which exceeds the maximum size of 32768`);if(this._powProvider){const n=await this._powProvider.pow(i,t);e.nonce=n.toString()}return(await this.fetchJson("post","messages",e)).messageId}async messageSubmitRaw(e){if(e.length>Te)throw new Error(`The message length is ${e.length}, which exceeds the maximum size of 32768`);if(this._powProvider&&t.ArrayHelper.equal(e.slice(-8),Se.NONCE_ZERO)){const{networkId:t,minPoWScore:n}=await this.getPoWInfo();s.BigIntHelper.write8(t,e,0);const i=await this._powProvider.pow(e,n);s.BigIntHelper.write8(r.default(i),e,e.length-8)}return(await this.fetchBinary("post","messages",e)).messageId}async messagesFind(e){return this.fetchJson("get",`messages?index=${"string"==typeof e?s.Converter.utf8ToHex(e):s.Converter.bytesToHex(e)}`)}async messageChildren(e){return this.fetchJson("get",`messages/${e}/children`)}async transactionIncludedMessage(e){return this.fetchJson("get",`transactions/${e}/included-message`)}async output(e){return this.fetchJson("get",`outputs/${e}`)}async address(e){return this.fetchJson("get",`addresses/${e}`)}async addressOutputs(e,t,n){const s=[];return void 0!==t&&s.push(`type=${t}`),void 0!==n&&s.push(`include-spent=${n}`),this.fetchJson("get",`addresses/${e}/outputs${this.combineQueryParams(s)}`)}async addressEd25519(e){if(!s.Converter.isHex(e))throw new Error("The supplied address does not appear to be hex format");return this.fetchJson("get",`addresses/ed25519/${e}`)}async addressEd25519Outputs(e,t,n){if(!s.Converter.isHex(e))throw new Error("The supplied address does not appear to be hex format");const i=[];return void 0!==t&&i.push(`type=${t}`),void 0!==n&&i.push(`include-spent=${n}`),this.fetchJson("get",`addresses/ed25519/${e}/outputs${this.combineQueryParams(i)}`)}async milestone(e){return this.fetchJson("get",`milestones/${e}`)}async milestoneUtxoChanges(e){return this.fetchJson("get",`milestones/${e}/utxo-changes`)}async treasury(){return this.fetchJson("get","treasury")}async receipts(e){return this.fetchJson("get","receipts"+(void 0!==e?`/${e}`:""))}async peers(){return this.fetchJson("get","peers")}async peerAdd(e,t){return this.fetchJson("post","peers",{multiAddress:e,alias:t})}async peerDelete(e){return this.fetchJson("delete",`peers/${e}`)}async peer(e){return this.fetchJson("get",`peers/${e}`)}async fetchStatus(e){return(await this.fetchWithTimeout("get",e)).status}async fetchJson(e,t,n){const s=await this.fetchWithTimeout(e,`${this._basePath}${t}`,{"Content-Type":"application/json"},n?JSON.stringify(n):void 0);let i,r;if(s.ok){if(204===s.status)return{};try{const e=await s.json();if(!e.error)return e.data;i=e.error.message,r=e.error.code}catch{}}if(!i)try{const e=await s.json();e.error&&(i=e.error.message,r=e.error.code)}catch{}if(!i)try{const e=await s.text();if(e.length>0){const t=/code=(\d+), message=(.*)/.exec(e);3===(null==t?void 0:t.length)?(r=t[1],i=t[2]):i=e}}catch{}throw new Ue(null!=i?i:s.statusText,t,s.status,null!=r?r:s.status.toString())}async fetchBinary(e,t,n){var s,i,r;const o=await this.fetchWithTimeout(e,`${this._basePath}${t}`,{"Content-Type":"application/octet-stream"},n);let a;if(o.ok){if("get"===e)return new Uint8Array(await o.arrayBuffer());if(a=await o.json(),!(null==a?void 0:a.error))return null==a?void 0:a.data}throw a||(a=await o.json()),new Ue(null!==(i=null===(s=null==a?void 0:a.error)||void 0===s?void 0:s.message)&&void 0!==i?i:o.statusText,t,o.status,null===(r=null==a?void 0:a.error)||void 0===r?void 0:r.code)}async fetchWithTimeout(e,t,n,i){let r,o;void 0!==this._timeout&&(r=new AbortController,o=setTimeout((()=>{r&&r.abort()}),this._timeout));const a={};if(this._headers)for(const e in this._headers)a[e]=this._headers[e];if(n)for(const e in n)a[e]=n[e];if(this._userName&&this._password){const e=s.Converter.bytesToBase64(s.Converter.utf8ToBytes(`${this._userName}:${this._password}`));a.Authorization=`Basic ${e}`}try{return await fetch(`${this._endpoint}${t}`,{method:e,headers:a,body:i,signal:r?r.signal:void 0})}catch(e){throw e instanceof Error&&"AbortError"===e.name?new Error("Timeout"):e}finally{o&&clearTimeout(o)}}combineQueryParams(e){return e.length>0?`?${e.join("&")}`:""}async getPoWInfo(){const e=await this.info(),n=t.Blake2b.sum256(s.Converter.utf8ToBytes(e.networkId));return{networkId:s.BigIntHelper.read8(n,0),minPoWScore:e.minPoWScore}}}Se.NONCE_ZERO=new Uint8Array([0,0,0,0,0,0,0,0]);class $e{static encodedLen(e){return e.length*$e.TRITS_PER_TRYTE}static encode(e,t,n){let s=0;for(let i=0;i<n.length;i++){const r=364+(n[i]<<24>>24),o=Math.trunc(r%27),a=Math.trunc(r/27);e[t+s]=$e.TRYTE_VALUE_TO_TRITS[o][0],e[t+s+1]=$e.TRYTE_VALUE_TO_TRITS[o][1],e[t+s+2]=$e.TRYTE_VALUE_TO_TRITS[o][2],e[t+s+3]=$e.TRYTE_VALUE_TO_TRITS[a][0],e[t+s+4]=$e.TRYTE_VALUE_TO_TRITS[a][1],e[t+s+5]=$e.TRYTE_VALUE_TO_TRITS[a][2],s+=6}return s}}$e.TRYTE_VALUE_TO_TRITS=[[-1,-1,-1],[0,-1,-1],[1,-1,-1],[-1,0,-1],[0,0,-1],[1,0,-1],[-1,1,-1],[0,1,-1],[1,1,-1],[-1,-1,0],[0,-1,0],[1,-1,0],[-1,0,0],[0,0,0],[1,0,0],[-1,1,0],[0,1,0],[1,1,0],[-1,-1,1],[0,-1,1],[1,-1,1],[-1,0,1],[0,0,1],[1,0,1],[-1,1,1],[0,1,1],[1,1,1]],$e.TRITS_PER_TRYTE=3;const Me="m/44'/4218'";function Pe(e){const n=new t.Bip32Path(Me);return n.pushHardened(e.accountIndex),n.pushHardened(e.isInternal?1:0),n.pushHardened(e.addressIndex),e.isInternal?(e.isInternal=!1,e.addressIndex++):e.isInternal=!0,n.toString()}class Ae{static toBech32(e,n,s){const i=new Uint8Array(1+n.length);return i[0]=e,i.set(n,1),t.Bech32.encode(s,i)}static fromBech32(e,n){const s=t.Bech32.decode(e);if(s){if(s.humanReadablePart!==n)throw new Error(`The hrp part of the address should be ${n}, it is ${s.humanReadablePart}`);if(0===s.data.length)throw new Error("The data part of the address should be at least length 1, it is 0");return{addressType:s.data[0],addressBytes:s.data.slice(1)}}}static matches(e,n){return t.Bech32.matches(n,e)}}async function Ne(e,t,n,s){var i;return ve(e,t,{accountIndex:n,addressIndex:null!==(i=null==s?void 0:s.startIndex)&&void 0!==i?i:0,isInternal:!1},Pe,s)}async function ve(e,n,i,r,a){var d,l;const u="string"==typeof e?new Se(e):e,c=await u.info(),p=null!==(d=null==a?void 0:a.requiredCount)&&void 0!==d?d:Number.MAX_SAFE_INTEGER,h=null!==(l=null==a?void 0:a.zeroCount)&&void 0!==l?l:20;let y=!1;const f=[];let g=0;do{const e=r(i),a=n.generateSeedFromPath(new t.Bip32Path(e)),d=new o(a.keyPair().publicKey).toAddress(),l=s.Converter.bytesToHex(d),m=await u.addressEd25519(l);0===m.balance?(g++,g>=h&&(y=!0)):(f.push({address:Ae.toBech32(0,d,c.bech32HRP),path:e,balance:m.balance}),f.length===p&&(y=!0))}while(!y);return f}async function Re(e,t){const n="string"==typeof e?new Se(e):e,s=await n.message(t);if(!s)throw new Error("The message does not exist.");const i=await n.tips();i.tipMessageIds.includes(t)||i.tipMessageIds.unshift(t),i.tipMessageIds.length>Ee&&(i.tipMessageIds=i.tipMessageIds.slice(0,Ee)),i.tipMessageIds.sort();const r={parentMessageIds:i.tipMessageIds};return{message:s,messageId:await n.messageSubmit(r)}}async function Be(e,t){const n="string"==typeof e?new Se(e):e,s=await n.message(t);if(!s)throw new Error("The message does not exist.");const i={payload:s.payload};return{message:s,messageId:await n.messageSubmit(i)}}async function ke(e,t,n,s){const i="string"==typeof e?new Se(e):e,r={payload:Oe(t,n,s)};return{messageId:await i.messageSubmit(r),message:r}}function Oe(e,n,i){if(!e||0===e.length)throw new Error("You must specify some inputs");if(!n||0===n.length)throw new Error("You must specify some outputs");let r;if(null==i?void 0:i.key){if(r="string"==typeof i.key?s.Converter.utf8ToHex(i.key):s.Converter.bytesToHex(i.key),r.length/2<1)throw new Error(`The indexation key length is ${r.length/2}, which is below the minimum size of 1`);if(r.length/2>oe)throw new Error(`The indexation key length is ${r.length/2}, which exceeds the maximum size of 64`)}const o=[];for(const e of n){if(0!==e.addressType)throw new Error(`Unrecognized output address type ${e.addressType}`);{const t={type:e.isDustAllowance?1:0,address:{type:e.addressType,address:e.address},amount:e.amount},n=new s.WriteStream;O(n,t),o.push({output:t,serialized:n.finalHex()})}}const a=e.map((e=>{const t=new s.WriteStream;return S(t,e.input),{...e,serialized:t.finalHex()}})).sort(((e,t)=>e.serialized.localeCompare(t.serialized))),d=o.sort(((e,t)=>e.serialized.localeCompare(t.serialized))),l={type:0,inputs:a.map((e=>e.input)),outputs:d.map((e=>e.output)),payload:r?{type:2,index:r,data:(null==i?void 0:i.data)?"string"==typeof i.data?s.Converter.utf8ToHex(i.data):s.Converter.bytesToHex(i.data):void 0}:void 0},u=new s.WriteStream;F(u,l);const c=u.finalBytes(),p=t.Blake2b.sum256(c),h=[],y={};for(const e of a){const n=s.Converter.bytesToHex(e.addressKeyPair.publicKey);y[n]?h.push({type:1,reference:y[n].unlockIndex}):(h.push({type:0,signature:{type:0,publicKey:n,signature:s.Converter.bytesToHex(t.Ed25519.sign(e.addressKeyPair.privateKey,p))}}),y[n]={keyPair:e.addressKeyPair,unlockIndex:h.length-1})}return{type:0,essence:l,unlockBlocks:h}}async function He(e,t,n,i,r,o){var a;const d="string"==typeof e?new Se(e):e,l=await d.info(),u=i.map((e=>{const t=Ae.fromBech32(e.addressBech32,l.bech32HRP);if(!t)throw new Error("Unable to decode bech32 address");return{address:s.Converter.bytesToHex(t.addressBytes),addressType:t.addressType,amount:e.amount,isDustAllowance:e.isDustAllowance}}));return be(e,t,{accountIndex:n,addressIndex:null!==(a=null==o?void 0:o.startIndex)&&void 0!==a?a:0,isInternal:!1},Pe,u,r,null==o?void 0:o.zeroCount)}async function Le(e,t,n,s,i,r){var o;const a=s.map((e=>({address:e.addressEd25519,addressType:0,amount:e.amount,isDustAllowance:e.isDustAllowance})));return be(e,t,{accountIndex:n,addressIndex:null!==(o=null==r?void 0:r.startIndex)&&void 0!==o?o:0,isInternal:!1},Pe,a,i,null==r?void 0:r.zeroCount)}async function be(e,t,n,s,i,r,o){const a=await ze(e,t,n,s,i,o),d=await ke(e,a,i,r);return{messageId:d.messageId,message:d.message}}async function ze(e,n,i,r,a,d=5){const l="string"==typeof e?new Se(e):e;let u=0;for(const e of a)u+=e.amount;let c=0;const p=[];let h=!1,y=0;do{const e=r(i),f=n.generateSeedFromPath(new t.Bip32Path(e)).keyPair(),g=new o(f.publicKey),m=s.Converter.bytesToHex(g.toAddress()),w=await l.addressEd25519Outputs(m);if(0===w.count)y++,y>=d&&(h=!0);else for(const e of w.outputIds){const t=await l.output(e);if(!t.isSpent&&c<u)if(0===t.output.amount)y++,y>=d&&(h=!0);else{c+=t.output.amount;const e={type:0,transactionId:t.transactionId,transactionOutputIndex:t.outputIndex};p.push({input:e,addressKeyPair:f}),c>=u&&(c-u>0&&a.push({amount:c-u,address:t.output.address.address,addressType:t.output.address.type}),h=!0)}}}while(!h);if(c<u)throw new Error("There are not enough funds in the inputs for the required balance");return p}var Ce;Ae.BECH32_DEFAULT_HRP_MAIN="iota",Ae.BECH32_DEFAULT_HRP_DEV="atoi",e.ConflictReason=void 0,(Ce=e.ConflictReason||(e.ConflictReason={}))[Ce.none=0]="none",Ce[Ce.inputUTXOAlreadySpent=1]="inputUTXOAlreadySpent",Ce[Ce.inputUTXOAlreadySpentInThisMilestone=2]="inputUTXOAlreadySpentInThisMilestone",Ce[Ce.inputUTXONotFound=3]="inputUTXONotFound",Ce[Ce.inputOutputSumMismatch=4]="inputOutputSumMismatch",Ce[Ce.invalidSignature=5]="invalidSignature",Ce[Ce.invalidDustAllowance=6]="invalidDustAllowance",Ce[Ce.semanticValidationFailed=255]="semanticValidationFailed";class Ge{static score(e){const n=e.slice(0,-8),i=t.Blake2b.sum256(n),r=s.BigIntHelper.read8(e,e.length-8),o=Ge.trailingZeros(i,r);return Math.pow(3,o)/e.length}static calculateTargetZeros(e,t){return Math.ceil(Math.log(e.length*t)/this.LN3)}static trailingZeros(e,n){const i=new Int8Array(t.Curl.HASH_LENGTH),r=$e.encode(i,0,e),o=new Uint8Array(8);s.BigIntHelper.write8(n,o,0),$e.encode(i,r,o);const a=new t.Curl;a.absorb(i,0,t.Curl.HASH_LENGTH);const d=new Int8Array(t.Curl.HASH_LENGTH);return a.squeeze(d,0,t.Curl.HASH_LENGTH),Ge.trinaryTrailingZeros(d)}static trinaryTrailingZeros(e,t=e.length){let n=0;for(let s=t-1;s>=0&&0===e[s];s--)n++;return n}static performPow(e,n,i){let o,a=r.default(i);const d=new Int8Array(t.Curl.HASH_LENGTH),l=$e.encode(d,0,e),u=new Uint8Array(8);do{s.BigIntHelper.write8(a,u,0),$e.encode(d,l,u);const e=new Int8Array(t.Curl.STATE_LENGTH);e.set(d,0),t.Curl.transform(e,81),Ge.trinaryTrailingZeros(e,t.Curl.HASH_LENGTH)>=n?o=a:a=a.plus(1)}while(void 0===o);return o?o.toString():"0"}}Ge.LN3=1.0986122886681098;const De={[e.ConflictReason.none]:"Not conflicting",[e.ConflictReason.inputUTXOAlreadySpent]:"The referenced UTXO was already spent",[e.ConflictReason.inputUTXOAlreadySpentInThisMilestone]:"The referenced UTXO was already spent while confirming this milestone",[e.ConflictReason.inputUTXONotFound]:"The referenced UTXO cannot be found",[e.ConflictReason.inputOutputSumMismatch]:"The sum of the inputs and output values does not match",[e.ConflictReason.invalidSignature]:"The unlock block signature is invalid",[e.ConflictReason.invalidDustAllowance]:"The dust allowance for the address is invalid",[e.ConflictReason.semanticValidationFailed]:"The semantic validation failed"};class Fe{constructor(e){this._secretKey=null!=e?e:new Uint8Array}static fromMnemonic(e){return new Fe(t.Bip39.mnemonicToSeed(e))}keyPair(){const e=t.Ed25519.keyPairFromSeed(this._secretKey);return{publicKey:e.publicKey,privateKey:e.privateKey}}generateSeedFromPath(e){const n=t.Slip0010.derivePath(this._secretKey,e);return new Fe(n.privateKey)}toBytes(){return this._secretKey}}let Ke=(e,t)=>void 0!==t?console.log(e,t):console.log(e);function Ye(e,t){t&&(0===t.type?We(e,t):1===t.type?Xe(e,t):2===t.type?qe(e,t):3===t.type?Ze(e,t):4===t.type&&Je(e,t))}function We(e,t){if(t){if(Ke(`${e}Transaction Payload`),0===t.essence.type){if(t.essence.inputs){Ke(`${e}\tInputs:`,t.essence.inputs.length);for(const n of t.essence.inputs)Qe(`${e}\t\t`,n)}if(t.essence.outputs){Ke(`${e}\tOutputs:`,t.essence.outputs.length);for(const n of t.essence.outputs)et(`${e}\t\t`,n)}}if(t.unlockBlocks){Ke(`${e}\tUnlock Blocks:`,t.unlockBlocks.length);for(const n of t.unlockBlocks)tt(`${e}\t\t`,n)}}}function qe(e,t){t&&(Ke(`${e}Indexation Payload`),Ke(`${e}\tIndex:`,s.Converter.hexToUtf8(t.index)),Ke(`${e}\tData:`,t.data?s.Converter.hexToUtf8(t.data):"None"))}function Xe(e,t){if(t){Ke(`${e}Milestone Payload`),Ke(`${e}\tIndex:`,t.index),Ke(`${e}\tTimestamp:`,t.timestamp);for(let n=0;n<t.parentMessageIds.length;n++)Ke(`${e}\tParent ${n+1}:`,t.parentMessageIds[n]);Ke(`${e}\tInclusion Merkle Proof:`,t.inclusionMerkleProof),t.nextPoWScore&&Ke(`${e}\tNext PoW Score:`,t.nextPoWScore),t.nextPoWScoreMilestoneIndex&&Ke(`${e}\tNext PoW Score Milestone Index:`,t.nextPoWScoreMilestoneIndex),Ke(`${e}\tPublic Keys:`,t.publicKeys),Ke(`${e}\tSignatures:`,t.signatures),Ze(`${e}\t`,t.receipt)}}function Ze(e,t){if(t){Ke(`${e}Receipt Payload`),Ke(`${e}\tMigrated At:`,t.migratedAt),Ke(`${e}\tFinal:`,t.final),Ke(`${e}\tFunds:`,t.funds.length);for(const n of t.funds)nt(`${e}\t\t`,n);Je(`${e}\t\t`,t.transaction)}}function Je(e,t){t&&(Ke(`${e}Treasury Transaction Payload`),Qe(e,t.input),et(e,t.output))}function je(e,t){if(0===(null==t?void 0:t.type)){const n=t;Ke(`${e}Ed25519 Address`),Ke(`${e}\tAddress:`,n.address)}}function Ve(e,t){if(0===(null==t?void 0:t.type)){const n=t;Ke(`${e}Ed25519 Signature`),Ke(`${e}\tPublic Key:`,n.publicKey),Ke(`${e}\tSignature:`,n.signature)}}function Qe(e,t){if(t)if(0===t.type){const n=t;Ke(`${e}UTXO Input`),Ke(`${e}\tTransaction Id:`,n.transactionId),Ke(`${e}\tTransaction Output Index:`,n.transactionOutputIndex)}else if(1===t.type){const n=t;Ke(`${e}Treasury Input`),Ke(`${e}\tMilestone Hash:`,n.milestoneId)}}function et(e,t){if(t)if(0===t.type){const n=t;Ke(`${e}Signature Locked Single Output`),je(`${e}\t\t`,n.address),Ke(`${e}\t\tAmount:`,n.amount)}else if(1===t.type){const n=t;Ke(`${e}Signature Locked Dust Allowance Output`),je(`${e}\t\t`,n.address),Ke(`${e}\t\tAmount:`,n.amount)}else if(2===t.type){const n=t;Ke(`${e}Treasury Output`),Ke(`${e}\t\tAmount:`,n.amount)}}function tt(e,t){if(t)if(0===t.type){const n=t;Ke(`${e}\tSignature Unlock Block`),Ve(`${e}\t\t`,n.signature)}else if(1===t.type){const n=t;Ke(`${e}\tReference Unlock Block`),Ke(`${e}\t\tReference:`,n.reference)}}function nt(e,t){t&&(Ke(`${e}\tFund`),Ke(`${e}\t\tTail Transaction Hash:`,t.tailTransactionHash),je(`${e}\t\t`,t.address),Ke(`${e}\t\tDeposit:`,t.deposit))}class st{static formatBest(e,t=2){return st.formatUnits(e,st.calculateBest(e),t)}static formatUnits(e,t,n=2){if(!st.UNIT_MAP[t])throw new Error(`Unrecognized unit ${t}`);return e?"i"===t?`${e} i`:`${st.convertUnits(e,"i",t).toFixed(n)} ${t}`:`0 ${t}`}static calculateBest(e){let t="i";if(!e)return t;const n=Math.abs(e).toString().length;return n>st.UNIT_MAP.Pi.dp?t="Pi":n>st.UNIT_MAP.Ti.dp?t="Ti":n>st.UNIT_MAP.Gi.dp?t="Gi":n>st.UNIT_MAP.Mi.dp?t="Mi":n>st.UNIT_MAP.Ki.dp&&(t="Ki"),t}static convertUnits(e,t,n){if(!e)return 0;if(!st.UNIT_MAP[t])throw new Error(`Unrecognized fromUnit ${t}`);if(!st.UNIT_MAP[n])throw new Error(`Unrecognized toUnit ${n}`);if("i"===t&&e%1!=0)throw new Error("If fromUnit is 'i' the value must be an integer value");if(t===n)return Number(e);const s=e<0?-1:1,i=Math.abs(Number(e))*st.UNIT_MAP[t].val/st.UNIT_MAP[n].val,r=st.UNIT_MAP[n].dp;let o=i.toString();o.includes("e")&&(o=i.toFixed(Number.parseInt(o.split("-")[1],10)));const a=o.split(".");return 1===a.length&&a.push("0"),a[1]=a[1].slice(0,r),Number.parseFloat(`${a[0]}.${a[1]}`)*s}}st.UNIT_MAP={i:{val:1,dp:0},Ki:{val:1e3,dp:3},Mi:{val:1e6,dp:6},Gi:{val:1e9,dp:9},Ti:{val:1e12,dp:12},Pi:{val:1e15,dp:15}},e.ARRAY_LENGTH=2,e.B1T6=$e,e.BYTE_SIZE=1,e.Bech32Helper=Ae,e.CONFLICT_REASON_STRINGS=De,e.ClientError=Ue,e.ED25519_ADDRESS_TYPE=0,e.ED25519_SEED_TYPE=1,e.ED25519_SIGNATURE_TYPE=0,e.Ed25519Address=o,e.Ed25519Seed=Fe,e.INDEXATION_PAYLOAD_TYPE=2,e.IOTA_BIP44_BASE_PATH=Me,e.LocalPowProvider=class{async pow(e,n){const s=e.slice(0,-8),i=t.Blake2b.sum256(s),r=Ge.calculateTargetZeros(e,n);return Ge.performPow(i,r,"0").toString()}},e.MAX_FUNDS_COUNT=127,e.MAX_INDEXATION_KEY_LENGTH=oe,e.MAX_INPUT_COUNT=127,e.MAX_MESSAGE_LENGTH=Te,e.MAX_NUMBER_PARENTS=Ee,e.MAX_OUTPUT_COUNT=127,e.MERKLE_PROOF_LENGTH=l,e.MESSAGE_ID_LENGTH=a,e.MILESTONE_PAYLOAD_TYPE=1,e.MIN_ADDRESS_LENGTH=1,e.MIN_ED25519_ADDRESS_LENGTH=u,e.MIN_ED25519_SIGNATURE_LENGTH=K,e.MIN_INDEXATION_KEY_LENGTH=1,e.MIN_INDEXATION_PAYLOAD_LENGTH=9,e.MIN_INPUT_COUNT=1,e.MIN_INPUT_LENGTH=1,e.MIN_MIGRATED_FUNDS_LENGTH=f,e.MIN_MILESTONE_PAYLOAD_LENGTH=se,e.MIN_NUMBER_PARENTS=_e,e.MIN_OUTPUT_COUNT=1,e.MIN_OUTPUT_LENGTH=1,e.MIN_PAYLOAD_LENGTH=4,e.MIN_RECEIPT_PAYLOAD_LENGTH=ie,e.MIN_REFERENCE_UNLOCK_BLOCK_LENGTH=3,e.MIN_SIGNATURE_LENGTH=1,e.MIN_SIGNATURE_UNLOCK_BLOCK_LENGTH=2,e.MIN_SIG_LOCKED_DUST_ALLOWANCE_OUTPUT_LENGTH=v,e.MIN_SIG_LOCKED_SINGLE_OUTPUT_LENGTH=N,e.MIN_TRANSACTION_ESSENCE_LENGTH=9,e.MIN_TRANSACTION_PAYLOAD_LENGTH=8,e.MIN_TREASURY_INPUT_LENGTH=E,e.MIN_TREASURY_OUTPUT_LENGTH=9,e.MIN_TREASURY_TRANSACTION_PAYLOAD_LENGTH=re,e.MIN_UNLOCK_BLOCK_LENGTH=1,e.MIN_UTXO_INPUT_LENGTH=T,e.PowHelper=Ge,e.RECEIPT_PAYLOAD_TYPE=3,e.REFERENCE_UNLOCK_BLOCK_TYPE=1,e.SIGNATURE_UNLOCK_BLOCK_TYPE=0,e.SIG_LOCKED_DUST_ALLOWANCE_OUTPUT_TYPE=1,e.SIG_LOCKED_SINGLE_OUTPUT_TYPE=0,e.SMALL_TYPE_LENGTH=1,e.STRING_LENGTH=2,e.SingleNodeClient=Se,e.TAIL_HASH_LENGTH=49,e.TRANSACTION_ESSENCE_TYPE=0,e.TRANSACTION_ID_LENGTH=d,e.TRANSACTION_PAYLOAD_TYPE=0,e.TREASURY_INPUT_TYPE=1,e.TREASURY_OUTPUT_TYPE=2,e.TREASURY_TRANSACTION_PAYLOAD_TYPE=4,e.TYPE_LENGTH=4,e.UINT16_SIZE=2,e.UINT32_SIZE=4,e.UINT64_SIZE=8,e.UTXO_INPUT_TYPE=0,e.UnitsHelper=st,e.buildTransactionPayload=Oe,e.calculateInputs=ze,e.deserializeAddress=c,e.deserializeEd25519Address=h,e.deserializeEd25519Signature=q,e.deserializeFunds=g,e.deserializeIndexationPayload=he,e.deserializeInput=U,e.deserializeInputs=_,e.deserializeMessage=function(e){if(!e.hasRemaining(Ie))throw new Error(`Message data is ${e.length()} in length which is less than the minimimum size required of ${Ie}`);const t=e.readUInt64("message.networkId"),n=e.readByte("message.numParents"),s=[];for(let t=0;t<n;t++){const n=e.readFixedHex(`message.parentMessageId${t}`,a);s.push(n)}const i=ae(e);if(i&&(3===i.type||4===i.type))throw new Error("Messages can not contain receipt or treasury transaction payloads");const r=e.readUInt64("message.nonce"),o=e.unused();if(0!==o)throw new Error(`Message data length ${e.length()} has unused data ${o}`);return{networkId:t.toString(10),parentMessageIds:s,payload:i,nonce:r.toString(10)}},e.deserializeMigratedFunds=w,e.deserializeMilestonePayload=ce,e.deserializeOutput=k,e.deserializeOutputs=R,e.deserializePayload=ae,e.deserializeReceiptPayload=fe,e.deserializeReferenceUnlockBlock=te,e.deserializeSigLockedDustAllowanceOutput=b,e.deserializeSigLockedSingleOutput=H,e.deserializeSignature=Y,e.deserializeSignatureUnlockBlock=Q,e.deserializeTransactionEssence=D,e.deserializeTransactionPayload=le,e.deserializeTreasuryInput=P,e.deserializeTreasuryOutput=C,e.deserializeTreasuryTransactionPayload=me,e.deserializeUTXOInput=$,e.deserializeUnlockBlock=j,e.deserializeUnlockBlocks=Z,e.generateBip44Address=Pe,e.generateBip44Path=function(e,n,s){const i=new t.Bip32Path(Me);return i.pushHardened(e),i.pushHardened(s?1:0),i.pushHardened(n),i},e.getBalance=async function(e,t,n,s){const i=await Ne(e,t,n,s);let r=0;for(const e of i)r+=e.balance;return r},e.getUnspentAddress=async function(e,t,n,s){const i=await Ne(e,t,n,{startIndex:null==s?void 0:s.startIndex,zeroCount:null==s?void 0:s.zeroCount,requiredCount:1});return i.length>0?i[0]:void 0},e.getUnspentAddresses=Ne,e.getUnspentAddressesWithAddressGenerator=ve,e.logAddress=je,e.logFunds=nt,e.logIndexationPayload=qe,e.logInfo=function(e,t){Ke(`${e}\tName:`,t.name),Ke(`${e}\tVersion:`,t.version),Ke(`${e}\tNetwork Id:`,t.networkId),Ke(`${e}\tIs Healthy:`,t.isHealthy),Ke(`${e}\tMin PoW Score:`,t.minPoWScore),Ke(`${e}\tBech32 HRP:`,t.bech32HRP),Ke(`${e}\tLatest Milestone Index:`,t.latestMilestoneIndex),Ke(`${e}\tLatest Milestone Timestamp:`,t.latestMilestoneTimestamp),Ke(`${e}\tConfirmed Milestone Index:`,t.confirmedMilestoneIndex),Ke(`${e}\tMessages Per Second:`,t.messagesPerSecond),Ke(`${e}\tReferenced Messages Per Second:`,t.referencedMessagesPerSecond),Ke(`${e}\tReferenced Rate:`,t.referencedRate),Ke(`${e}\tPruning Index:`,t.pruningIndex),Ke(`${e}\tFeatures:`,t.features)},e.logInput=Qe,e.logMessage=function(e,t){if(Ke(`${e}\tNetwork Id:`,t.networkId),t.parentMessageIds)for(let n=0;n<t.parentMessageIds.length;n++)Ke(`${e}\tParent ${n+1} Message Id:`,t.parentMessageIds[n]);Ye(`${e}\t`,t.payload),void 0!==t.nonce&&Ke(`${e}\tNonce:`,t.nonce)},e.logMessageMetadata=function(e,t){if(Ke(`${e}\tMessage Id:`,t.messageId),t.parentMessageIds)for(let n=0;n<t.parentMessageIds.length;n++)Ke(`${e}\tParent ${n+1} Message Id:`,t.parentMessageIds[n]);void 0!==t.isSolid&&Ke(`${e}\tIs Solid:`,t.isSolid),void 0!==t.milestoneIndex&&Ke(`${e}\tMilestone Index:`,t.milestoneIndex),void 0!==t.referencedByMilestoneIndex&&Ke(`${e}\tReferenced By Milestone Index:`,t.referencedByMilestoneIndex),Ke(`${e}\tLedger Inclusion State:`,t.ledgerInclusionState),void 0!==t.conflictReason&&Ke(`${e}\tConflict Reason:`,t.conflictReason),void 0!==t.shouldPromote&&Ke(`${e}\tShould Promote:`,t.shouldPromote),void 0!==t.shouldReattach&&Ke(`${e}\tShould Reattach:`,t.shouldReattach)},e.logMilestonePayload=Xe,e.logOutput=et,e.logPayload=Ye,e.logReceiptPayload=Ze,e.logSignature=Ve,e.logTips=function(e,t){if(t.tipMessageIds)for(let n=0;n<t.tipMessageIds.length;n++)Ke(`${e}\tTip ${n+1} Message Id:`,t.tipMessageIds[n])},e.logTransactionPayload=We,e.logTreasuryTransactionPayload=Je,e.logUnlockBlock=tt,e.promote=Re,e.reattach=Be,e.retrieveData=async function(e,t){const n="string"==typeof e?new Se(e):e,i=await n.message(t);if(null==i?void 0:i.payload){let e;if(0===i.payload.type?e=i.payload.essence.payload:2===i.payload.type&&(e=i.payload),e)return{index:s.Converter.hexToBytes(e.index),data:e.data?s.Converter.hexToBytes(e.data):void 0}}},e.retry=async function(e,t){const n="string"==typeof e?new Se(e):e,s=await n.messageMetadata(t);if(!s)throw new Error("The message does not exist.");if(s.shouldPromote)return Re(e,t);if(s.shouldReattach)return Be(e,t);throw new Error("The message should not be promoted or reattached.")},e.send=async function(e,t,n,s,i,r,o){return He(e,t,n,[{addressBech32:s,amount:i}],r,o)},e.sendAdvanced=ke,e.sendData=async function(e,t,n){const i="string"==typeof e?new Se(e):e;if(!t)throw new Error("indexationKey must not be empty");const r="string"==typeof t?s.Converter.utf8ToHex(t):s.Converter.bytesToHex(t);if(r.length/2<1)throw new Error(`The indexation key length is ${r.length/2}, which is below the minimum size of 1`);if(r.length/2>oe)throw new Error(`The indexation key length is ${r.length/2}, which exceeds the maximum size of 64`);const o={payload:{type:2,index:r,data:n?"string"==typeof n?s.Converter.utf8ToHex(n):s.Converter.bytesToHex(n):void 0}};return{message:o,messageId:await i.messageSubmit(o)}},e.sendEd25519=async function(e,t,n,s,i,r,o){return Le(e,t,n,[{addressEd25519:s,amount:i}],r,o)},e.sendMultiple=He,e.sendMultipleEd25519=Le,e.sendWithAddressGenerator=be,e.serializeAddress=p,e.serializeEd25519Address=y,e.serializeEd25519Signature=X,e.serializeFunds=m,e.serializeIndexationPayload=ye,e.serializeInput=S,e.serializeInputs=x,e.serializeMessage=xe,e.serializeMigratedFunds=I,e.serializeMilestonePayload=pe,e.serializeOutput=O,e.serializeOutputs=B,e.serializePayload=de,e.serializeReceiptPayload=ge,e.serializeReferenceUnlockBlock=ne,e.serializeSigLockedDustAllowanceOutput=z,e.serializeSigLockedSingleOutput=L,e.serializeSignature=W,e.serializeSignatureUnlockBlock=ee,e.serializeTransactionEssence=F,e.serializeTransactionPayload=ue,e.serializeTreasuryInput=A,e.serializeTreasuryOutput=G,e.serializeTreasuryTransactionPayload=we,e.serializeUTXOInput=M,e.serializeUnlockBlock=V,e.serializeUnlockBlocks=J,e.setLogger=function(e){Ke=e},Object.defineProperty(e,"__esModule",{value:!0})}));